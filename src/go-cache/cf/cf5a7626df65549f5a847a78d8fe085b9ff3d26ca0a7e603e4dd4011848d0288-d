// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/omar-gerson/Fullstack/gerson-calendar/src/go/pkg/mod/github.com/wailsapp/wails/v2@v2.11.0/internal/frontend/desktop/linux/menu.go:1:1
//go:build linux
// +build linux

package linux

/*
#cgo linux pkg-config: gtk+-3.0
#cgo !webkit2_41 pkg-config: webkit2gtk-4.0
#cgo webkit2_41 pkg-config: webkit2gtk-4.1

#include "gtk/gtk.h"

static GtkMenuItem *toGtkMenuItem(void *pointer) { return (GTK_MENU_ITEM(pointer)); }
static GtkMenuShell *toGtkMenuShell(void *pointer) { return (GTK_MENU_SHELL(pointer)); }
static GtkCheckMenuItem *toGtkCheckMenuItem(void *pointer) { return (GTK_CHECK_MENU_ITEM(pointer)); }
static GtkRadioMenuItem *toGtkRadioMenuItem(void *pointer) { return (GTK_RADIO_MENU_ITEM(pointer)); }

extern void handleMenuItemClick(void*);

void blockClick(GtkWidget* menuItem, gulong handler_id) {
	g_signal_handler_block (menuItem, handler_id);
}

void unblockClick(GtkWidget* menuItem, gulong handler_id) {
	g_signal_handler_unblock (menuItem, handler_id);
}

gulong connectClick(GtkWidget* menuItem) {
	return g_signal_connect(menuItem, "activate", G_CALLBACK(handleMenuItemClick), (void*)menuItem);
}

void addAccelerator(GtkWidget* menuItem, GtkAccelGroup* group, guint key, GdkModifierType mods) {
	gtk_widget_add_accelerator(menuItem, "activate", group, key, mods, GTK_ACCEL_VISIBLE);
}
*/
import _ "unsafe"
import (
	"unsafe"

	"github.com/wailsapp/wails/v2/pkg/menu"
)

var menuIdCounter int
var menuItemToId map[*menu.MenuItem]int
var menuIdToItem map[int]*menu.MenuItem
var gtkCheckboxCache map[*menu.MenuItem][]* /*line :46:44*/_Ctype_GtkWidget /*line :46:55*/
var gtkMenuCache map[*menu.MenuItem]* /*line :47:38*/_Ctype_GtkWidget /*line :47:49*/
var gtkRadioMenuCache map[*menu.MenuItem][]* /*line :48:45*/_Ctype_GtkWidget /*line :48:56*/
var gtkSignalHandlers map[* /*line :49:28*/_Ctype_GtkWidget /*line :49:39*/] /*line :49:40*/_Ctype_gulong /*line :49:48*/
var gtkSignalToMenuItem map[* /*line :50:30*/_Ctype_GtkWidget /*line :50:41*/]*menu.MenuItem

func (f *Frontend) MenuSetApplicationMenu(menu *menu.Menu) {
	f.mainWindow.SetApplicationMenu(menu)
}

func (f *Frontend) MenuUpdateApplicationMenu() {
	f.mainWindow.SetApplicationMenu(f.mainWindow.applicationMenu)
}

func (w *Window) SetApplicationMenu(inmenu *menu.Menu) {
	if inmenu == nil {
		return
	}

	// Setup accelerator group
	w.accels = ( /*line :66:13*/_Cfunc_gtk_accel_group_new /*line :66:33*/)()
	func() { _cgo0 := /*line :67:31*/w.asGTKWindow(); _cgo1 := /*line :67:48*/w.accels; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :67:57*/_Cfunc_gtk_window_add_accel_group(_cgo0, _cgo1); }()

	menuItemToId = make(map[*menu.MenuItem]int)
	menuIdToItem = make(map[int]*menu.MenuItem)
	gtkCheckboxCache = make(map[*menu.MenuItem][]* /*line :71:48*/_Ctype_GtkWidget /*line :71:59*/)
	gtkMenuCache = make(map[*menu.MenuItem]* /*line :72:42*/_Ctype_GtkWidget /*line :72:53*/)
	gtkRadioMenuCache = make(map[*menu.MenuItem][]* /*line :73:49*/_Ctype_GtkWidget /*line :73:60*/)
	gtkSignalHandlers = make(map[* /*line :74:32*/_Ctype_GtkWidget /*line :74:43*/] /*line :74:44*/_Ctype_gulong /*line :74:52*/)
	gtkSignalToMenuItem = make(map[* /*line :75:34*/_Ctype_GtkWidget /*line :75:45*/]*menu.MenuItem)

	// Increase ref count?
	w.menubar = ( /*line :78:14*/_Cfunc_gtk_menu_bar_new /*line :78:31*/)()

	processMenu(w, inmenu)

	func() { _cgo0 := /*line :82:20*/w.menubar; _cgoCheckPointer(_cgo0, nil); /*line :82:30*/_Cfunc_gtk_widget_show(_cgo0); }()
}

func processMenu(window *Window, menu *menu.Menu) {
	for _, menuItem := range menu.Items {
		if menuItem.SubMenu != nil {
			submenu := processSubmenu(menuItem, window.accels)
			func() { _cgo0 := func() *_Ctype_struct__GtkMenuShell{ _cgo0 := /*line :89:45*/unsafe.Pointer(window.menubar); _cgoCheckPointer(_cgo0, nil); return /*line :89:76*/_Cfunc_toGtkMenuShell(_cgo0); }(); _cgo1 := /*line :89:78*/submenu; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :89:86*/_Cfunc_gtk_menu_shell_append(_cgo0, _cgo1); }()
		}
	}
}

func processSubmenu(menuItem *menu.MenuItem, group * /*line :94:53*/_Ctype_GtkAccelGroup /*line :94:68*/) * /*line :94:71*/_Ctype_GtkWidget /*line :94:82*/ {
	existingMenu := gtkMenuCache[menuItem]
	if existingMenu != nil {
		return existingMenu
	}
	gtkMenu := ( /*line :99:13*/_Cfunc_gtk_menu_new /*line :99:26*/)()
	submenu := GtkMenuItemWithLabel(menuItem.Label)
	for _, menuItem := range menuItem.SubMenu.Items {
		menuID := menuIdCounter
		menuIdToItem[menuID] = menuItem
		menuItemToId[menuItem] = menuID
		menuIdCounter++
		processMenuItem(gtkMenu, menuItem, group)
	}
	func() { _cgo0 := func() *_Ctype_struct__GtkMenuItem{ _cgo0 := /*line :108:46*/unsafe.Pointer(submenu); _cgoCheckPointer(_cgo0, nil); return /*line :108:70*/_Cfunc_toGtkMenuItem(_cgo0); }(); _cgo1 := /*line :108:72*/gtkMenu; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :108:80*/_Cfunc_gtk_menu_item_set_submenu(_cgo0, _cgo1); }()
	gtkMenuCache[menuItem] = existingMenu
	return submenu
}

var currentRadioGroup * /*line :113:24*/_Ctype_GSList /*line :113:32*/

func processMenuItem(parent * /*line :115:30*/_Ctype_GtkWidget /*line :115:41*/, menuItem *menu.MenuItem, group * /*line :115:75*/_Ctype_GtkAccelGroup /*line :115:90*/) {
	if menuItem.Hidden {
		return
	}

	if menuItem.Type != menu.RadioType {
		currentRadioGroup = nil
	}

	if menuItem.Type == menu.SeparatorType {
		result := ( /*line :125:13*/_Cfunc_gtk_separator_menu_item_new /*line :125:41*/)()
		func() { _cgo0 := func() *_Ctype_struct__GtkMenuShell{ _cgo0 := /*line :126:44*/unsafe.Pointer(parent); _cgoCheckPointer(_cgo0, nil); return /*line :126:67*/_Cfunc_toGtkMenuShell(_cgo0); }(); _cgo1 := /*line :126:69*/result; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :126:76*/_Cfunc_gtk_menu_shell_append(_cgo0, _cgo1); }()
		return
	}

	var result * /*line :130:14*/_Ctype_GtkWidget /*line :130:25*/

	switch menuItem.Type {
	case menu.TextType:
		result = GtkMenuItemWithLabel(menuItem.Label)
	case menu.CheckboxType:
		result = GtkCheckMenuItemWithLabel(menuItem.Label)
		if menuItem.Checked {
			func() { _cgo0 := func() *_Ctype_struct__GtkCheckMenuItem{ _cgo0 := /*line :138:58*/unsafe.Pointer(result); _cgoCheckPointer(_cgo0, nil); return /*line :138:81*/_Cfunc_toGtkCheckMenuItem(_cgo0); }(); var _cgo1 _Ctype_gboolean = /*line :138:83*/1; _cgoCheckPointer(_cgo0, nil); /*line :138:85*/_Cfunc_gtk_check_menu_item_set_active(_cgo0, _cgo1); }()
		}
		gtkCheckboxCache[menuItem] = append(gtkCheckboxCache[menuItem], result)

	case menu.RadioType:
		result = GtkRadioMenuItemWithLabel(menuItem.Label, currentRadioGroup)
		currentRadioGroup = func() *_Ctype_struct__GSList{ _cgo0 := func() *_Ctype_struct__GtkRadioMenuItem{ _cgo0 := /*line :144:76*/unsafe.Pointer(result); _cgoCheckPointer(_cgo0, nil); return /*line :144:99*/_Cfunc_toGtkRadioMenuItem(_cgo0); }(); _cgoCheckPointer(_cgo0, nil); return /*line :144:100*/_Cfunc_gtk_radio_menu_item_get_group(_cgo0); }()
		if menuItem.Checked {
			func() { _cgo0 := func() *_Ctype_struct__GtkCheckMenuItem{ _cgo0 := /*line :146:58*/unsafe.Pointer(result); _cgoCheckPointer(_cgo0, nil); return /*line :146:81*/_Cfunc_toGtkCheckMenuItem(_cgo0); }(); var _cgo1 _Ctype_gboolean = /*line :146:83*/1; _cgoCheckPointer(_cgo0, nil); /*line :146:85*/_Cfunc_gtk_check_menu_item_set_active(_cgo0, _cgo1); }()
		}
		gtkRadioMenuCache[menuItem] = append(gtkRadioMenuCache[menuItem], result)
	case menu.SubmenuType:
		result = processSubmenu(menuItem, group)
	}
	func() { _cgo0 := func() *_Ctype_struct__GtkMenuShell{ _cgo0 := /*line :152:43*/unsafe.Pointer(parent); _cgoCheckPointer(_cgo0, nil); return /*line :152:66*/_Cfunc_toGtkMenuShell(_cgo0); }(); _cgo1 := /*line :152:68*/result; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :152:75*/_Cfunc_gtk_menu_shell_append(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :153:20*/result; _cgoCheckPointer(_cgo0, nil); /*line :153:27*/_Cfunc_gtk_widget_show(_cgo0); }()

	if menuItem.Click != nil {
		handler := func() _Ctype_gulong{ _cgo0 := /*line :156:29*/result; _cgoCheckPointer(_cgo0, nil); return /*line :156:36*/_Cfunc_connectClick(_cgo0); }()
		gtkSignalHandlers[result] = handler
		gtkSignalToMenuItem[result] = menuItem
	}

	if menuItem.Disabled {
		func() { _cgo0 := /*line :162:30*/result; var _cgo1 _Ctype_gboolean = /*line :162:38*/0; _cgoCheckPointer(_cgo0, nil); /*line :162:40*/_Cfunc_gtk_widget_set_sensitive(_cgo0, _cgo1); }()
	}

	if menuItem.Accelerator != nil {
		key, mods := acceleratorToGTK(menuItem.Accelerator)
		func() { _cgo0 := /*line :167:20*/result; _cgo1 := /*line :167:28*/group; var _cgo2 _Ctype_guint = /*line :167:35*/key; var _cgo3 _Ctype_GdkModifierType = /*line :167:40*/mods; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :167:45*/_Cfunc_addAccelerator(_cgo0, _cgo1, _cgo2, _cgo3); }()
	}
}
