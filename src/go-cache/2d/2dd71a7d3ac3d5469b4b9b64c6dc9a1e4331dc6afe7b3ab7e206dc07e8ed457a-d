// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/omar-gerson/Fullstack/gerson-calendar/src/go/pkg/mod/github.com/wailsapp/wails/v2@v2.11.0/pkg/assetserver/webview/responsewriter_linux.go:1:1
//go:build linux
// +build linux

package webview

/*
#cgo linux pkg-config: gtk+-3.0 gio-unix-2.0
#cgo !webkit2_41 pkg-config: webkit2gtk-4.0
#cgo webkit2_41 pkg-config: webkit2gtk-4.1

#include "gtk/gtk.h"
#include "webkit2/webkit2.h"
#include "gio/gunixinputstream.h"

*/
import _ "unsafe"
import (
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"
	"syscall"
	"unsafe"
)

type responseWriter struct {
	req * /*line :28:7*/_Ctype_WebKitURISchemeRequest /*line :28:31*/

	header      http.Header
	wroteHeader bool
	finished    bool

	w    io.WriteCloser
	wErr error
}

func (rw *responseWriter) Header() http.Header {
	if rw.header == nil {
		rw.header = http.Header{}
	}
	return rw.header
}

func (rw *responseWriter) Write(buf []byte) (int, error) {
	if rw.finished {
		return 0, errResponseFinished
	}

	rw.WriteHeader(http.StatusOK)
	if rw.wErr != nil {
		return 0, rw.wErr
	}
	return rw.w.Write(buf)
}

func (rw *responseWriter) WriteHeader(code int) {
	if rw.wroteHeader || rw.finished {
		return
	}
	rw.wroteHeader = true

	contentLength := int64(-1)
	if sLen := rw.Header().Get(HeaderContentLength); sLen != "" {
		if pLen, _ := strconv.ParseInt(sLen, 10, 64); pLen > 0 {
			contentLength = pLen
		}
	}

	// We can't use os.Pipe here, because that returns files with a finalizer for closing the FD. But the control over the
	// read FD is given to the InputStream and will be closed there.
	// Furthermore we especially don't want to have the FD_CLOEXEC
	rFD, w, err := pipe()
	if err != nil {
		rw.finishWithError(http.StatusInternalServerError, fmt.Errorf("unable to open pipe: %s", err))
		return
	}
	rw.w = w

	stream := ( /*line :80:12*/_Cfunc_g_unix_input_stream_new /*line :80:36*/)( /*line :80:38*/_Ctype_int /*line :80:43*/(rFD),  /*line :80:50*/_Ctype_gboolean /*line :80:60*/(1))
	defer func() func() { _cgo0 := _Ctype_gpointer /*line :81:35*/(stream); return func() { _cgoCheckPointer(_cgo0, nil); /*line :81:44*/_Cfunc_g_object_unref(_cgo0); }}()()

	if err := webkit_uri_scheme_request_finish(rw.req, code, rw.Header(), stream, contentLength); err != nil {
		rw.finishWithError(http.StatusInternalServerError, fmt.Errorf("unable to finish request: %s", err))
		return
	}
}

func (rw *responseWriter) Finish() error {
	if !rw.wroteHeader {
		rw.WriteHeader(http.StatusNotImplemented)
	}

	if rw.finished {
		return nil
	}
	rw.finished = true
	if rw.w != nil {
		rw.w.Close()
	}
	return nil
}

func (rw *responseWriter) finishWithError(code int, err error) {
	if rw.w != nil {
		rw.w.Close()
		rw.w = &nopCloser{io.Discard}
	}
	rw.wErr = err

	msg := ( /*line :111:9*/_Cfunc_CString /*line :111:17*/)(err.Error())
	gerr := ( /*line :112:10*/_Cfunc_g_error_new_literal /*line :112:30*/)(( /*line :112:32*/_Cfunc_g_quark_from_string /*line :112:52*/)(msg),  /*line :112:60*/_Ctype_int /*line :112:65*/(code), msg)
	func() { _cgo0 := /*line :113:43*/rw.req; _cgo1 := /*line :113:51*/gerr; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :113:56*/_Cfunc_webkit_uri_scheme_request_finish_error(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :114:17*/gerr; _cgoCheckPointer(_cgo0, nil); /*line :114:22*/_Cfunc_g_error_free(_cgo0); }()
	func() { _cgo0 := /*line :115:9*/unsafe.Pointer(msg); _cgoCheckPointer(_cgo0, nil); /*line :115:29*/_Cfunc_free(_cgo0); }()
}

type nopCloser struct {
	io.Writer
}

func (nopCloser) Close() error { return nil }

func pipe() (r int, w *os.File, err error) {
	var p [2]int
	e := syscall.Pipe2(p[0:], 0)
	if e != nil {
		return 0, nil, fmt.Errorf("pipe2: %s", e)
	}

	return p[0], os.NewFile(uintptr(p[1]), "|1"), nil
}
