// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/omar-gerson/Fullstack/gerson-calendar/src/go/pkg/mod/github.com/wailsapp/wails/v2@v2.11.0/internal/frontend/desktop/linux/gtk.go:1:1
//go:build linux
// +build linux

package linux

/*
#cgo linux pkg-config: gtk+-3.0
#cgo !webkit2_41 pkg-config: webkit2gtk-4.0
#cgo webkit2_41 pkg-config: webkit2gtk-4.1

#include "gtk/gtk.h"

static GtkCheckMenuItem *toGtkCheckMenuItem(void *pointer) { return (GTK_CHECK_MENU_ITEM(pointer)); }

extern void blockClick(GtkWidget* menuItem, gulong handler_id);
extern void unblockClick(GtkWidget* menuItem, gulong handler_id);
*/
import _ "unsafe"
import (
	"unsafe"

	"github.com/wailsapp/wails/v2/pkg/menu"
)

func GtkMenuItemWithLabel(label string) * /*line :25:42*/_Ctype_GtkWidget /*line :25:53*/ {
	cLabel := ( /*line :26:12*/_Cfunc_CString /*line :26:20*/)(label)
	result := ( /*line :27:12*/_Cfunc_gtk_menu_item_new_with_label /*line :27:41*/)(cLabel)
	func() { _cgo0 := /*line :28:9*/unsafe.Pointer(cLabel); _cgoCheckPointer(_cgo0, nil); /*line :28:32*/_Cfunc_free(_cgo0); }()
	return result
}

func GtkCheckMenuItemWithLabel(label string) * /*line :32:47*/_Ctype_GtkWidget /*line :32:58*/ {
	cLabel := ( /*line :33:12*/_Cfunc_CString /*line :33:20*/)(label)
	result := ( /*line :34:12*/_Cfunc_gtk_check_menu_item_new_with_label /*line :34:47*/)(cLabel)
	func() { _cgo0 := /*line :35:9*/unsafe.Pointer(cLabel); _cgoCheckPointer(_cgo0, nil); /*line :35:32*/_Cfunc_free(_cgo0); }()
	return result
}

func GtkRadioMenuItemWithLabel(label string, group * /*line :39:53*/_Ctype_GSList /*line :39:61*/) * /*line :39:64*/_Ctype_GtkWidget /*line :39:75*/ {
	cLabel := ( /*line :40:12*/_Cfunc_CString /*line :40:20*/)(label)
	result := func() *_Ctype_struct__GtkWidget{ _cgo0 := /*line :41:49*/group; var _cgo1 *_Ctype_gchar = /*line :41:56*/cLabel; _cgoCheckPointer(_cgo0, nil); return /*line :41:63*/_Cfunc_gtk_radio_menu_item_new_with_label(_cgo0, _cgo1); }()
	func() { _cgo0 := /*line :42:9*/unsafe.Pointer(cLabel); _cgoCheckPointer(_cgo0, nil); /*line :42:32*/_Cfunc_free(_cgo0); }()
	return result
}

//export handleMenuItemClick
func handleMenuItemClick(gtkWidget unsafe.Pointer) {
	// Make sure to execute the final callback on a new goroutine otherwise if the callback e.g. tries to open a dialog, the
	// main thread will get blocked and so the message loop blocks. As a result the app will block and shows a
	// "not responding" dialog.

	item := gtkSignalToMenuItem[(* /*line :52:32*/_Ctype_GtkWidget /*line :52:43*/)(gtkWidget)]
	switch item.Type {
	case menu.CheckboxType:
		item.Checked = !item.Checked
		checked :=  /*line :56:14*/_Ctype_int /*line :56:19*/(0)
		if item.Checked {
			checked =  /*line :58:14*/_Ctype_int /*line :58:19*/(1)
		}
		for _, gtkCheckbox := range gtkCheckboxCache[item] {
			handler := gtkSignalHandlers[gtkCheckbox]
			func() { _cgo0 := /*line :62:17*/gtkCheckbox; var _cgo1 _Ctype_gulong = /*line :62:30*/handler; _cgoCheckPointer(_cgo0, nil); /*line :62:38*/_Cfunc_blockClick(_cgo0, _cgo1); }()
			func() { _cgo0 := func() *_Ctype_struct__GtkCheckMenuItem{ _cgo0 := /*line :63:58*/unsafe.Pointer(gtkCheckbox); _cgoCheckPointer(_cgo0, nil); return /*line :63:86*/_Cfunc_toGtkCheckMenuItem(_cgo0); }(); var _cgo1 _Ctype_gboolean = /*line :63:88*/checked; _cgoCheckPointer(_cgo0, nil); /*line :63:96*/_Cfunc_gtk_check_menu_item_set_active(_cgo0, _cgo1); }()
			func() { _cgo0 := /*line :64:19*/gtkCheckbox; var _cgo1 _Ctype_gulong = /*line :64:32*/handler; _cgoCheckPointer(_cgo0, nil); /*line :64:40*/_Cfunc_unblockClick(_cgo0, _cgo1); }()
		}
		go item.Click(&menu.CallbackData{MenuItem: item})
	case menu.RadioType:
		gtkRadioItems := gtkRadioMenuCache[item]
		active := func() _Ctype_gboolean{ _cgo0 := func() *_Ctype_struct__GtkCheckMenuItem{ _cgo0 := /*line :69:67*/gtkWidget; _cgoCheckPointer(_cgo0, nil); return /*line :69:77*/_Cfunc_toGtkCheckMenuItem(_cgo0); }(); _cgoCheckPointer(_cgo0, nil); return /*line :69:78*/_Cfunc_gtk_check_menu_item_get_active(_cgo0); }()
		if int(active) == 1 {
			for _, gtkRadioItem := range gtkRadioItems {
				handler := gtkSignalHandlers[gtkRadioItem]
				func() { _cgo0 := /*line :73:18*/gtkRadioItem; var _cgo1 _Ctype_gulong = /*line :73:32*/handler; _cgoCheckPointer(_cgo0, nil); /*line :73:40*/_Cfunc_blockClick(_cgo0, _cgo1); }()
				func() { _cgo0 := func() *_Ctype_struct__GtkCheckMenuItem{ _cgo0 := /*line :74:59*/unsafe.Pointer(gtkRadioItem); _cgoCheckPointer(_cgo0, nil); return /*line :74:88*/_Cfunc_toGtkCheckMenuItem(_cgo0); }(); var _cgo1 _Ctype_gboolean = /*line :74:90*/1; _cgoCheckPointer(_cgo0, nil); /*line :74:92*/_Cfunc_gtk_check_menu_item_set_active(_cgo0, _cgo1); }()
				func() { _cgo0 := /*line :75:20*/gtkRadioItem; var _cgo1 _Ctype_gulong = /*line :75:34*/handler; _cgoCheckPointer(_cgo0, nil); /*line :75:42*/_Cfunc_unblockClick(_cgo0, _cgo1); }()
			}
			item.Checked = true
			go item.Click(&menu.CallbackData{MenuItem: item})
		} else {
			item.Checked = false
		}
	default:
		go item.Click(&menu.CallbackData{MenuItem: item})
	}
}
